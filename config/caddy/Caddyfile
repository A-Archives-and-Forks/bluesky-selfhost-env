#
# this mapping rules are converted into Caddyfile from traefik rules of https://github.com/ikuradon/atproto-starter-kit/blob/main/compose.yaml
# cf. https://caddyserver.com/docs/caddyfile
#
# global options: starts >>>>
{
#	debug
        on_demand_tls {
          ask http://caddy-sidecar:80
        }
}
# global options: ends   <<<<

# self-hosting CA with ACME,  for self signed certicates >>>>
#   accessible as https://ca.DOMAIN:9000/acme/local/directory
#   cf. https://blog.kurokobo.com/archives/3669#Caddy_acme_server
#
ca.{$DOMAIN}:9000 {
	tls internal
	acme_server
}
# self-hosting CA with ACME,  for self signed certicates <<<<

# starts; reverse proxying rules >>>>>
#
#  FQDN_FOR_OUTER {
#	tls internal(for self-signed) | your@email.address(for public-signed) {
#         on_demand
#       }
#       reverse_proxy http://container:port
# }

# starts: to check if sidecar working, this record maybe need just for debugging. >>>>
caddy-sidecar.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://caddy-sidecar:80
}
# ends: to check if sidecar working, this record maybe need just for debugging. <<<<

# starts: to check if caddy works as reverse proxy, for HTTPS=>HTTP and WSS=>WS >>>>>>>>>>
test-ws.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
#
# this block seems no need, even https://caddy.community/t/websockets-over-https/16871 says it needed... <<<<<
#	@ws {
#		header Connection *Upgrade*
#		header Upgrade websocket
#	}
#
	reverse_proxy http://test-ws:8080

# below line also seems no need.
#	reverse_proxy @ws http://test-ws:8080

}
# ends: to check if caddy works as reverse proxy, for HTTPS=>HTTP and WSS=>WS >>>>>>>>>>

# starts: simple mapping >>>>>

plc.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://plc:3000
}

bgs.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://bgs:2470
}

api.{$DOMAIN}, bsky.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://bsky:3000
}

pds.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://pds:3000
}

social-app.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://social-app:8100
}

mod.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://mod:3000
}

search.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://search:3999
}

feed-generator.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://feed-generator:3000
}

# ends:  simple mapping <<<<<

# starts:  DOMAIN and requiring rewrite >>>>>>>>>>>

{$DOMAIN} {
        tls {$EMAIL4CERTS} {
          on_demand
        }
        redir /xrpc*        https://pds.{$DOMAIN}{uri}
        redir /.well-known* https://pds.{$DOMAIN}{uri}
        redir /robots.txt*  https://pds.{$DOMAIN}{uri}

        # others (default)
        redir               https://social-app.{$DOMAIN}{uri}
}

*.{$DOMAIN} {
        tls {$EMAIL4CERTS} {
          on_demand
        }
        redir /xrpc*        https://pds.{$DOMAIN}{uri}
        redir /.well-known* https://pds.{$DOMAIN}{uri}
        redir /robots.txt*  https://pds.{$DOMAIN}{uri}

        # others:  redirect with regex rewrite "^https://(.*).{$DOMAIN}/(.*)" => "https://{$DOMAIN}/profile/$${1}/$${2}"
        #    cf. https://github.com/caddyserver/caddy/issues/6142 and  https://www.regular-expressions.info/refext.html
        @matcher {
            header_regexp host Host ^(?P<some>.*)\.{$DOMAIN}$
        }
        redir  @matcher https://{$DOMAIN}/profile/{http.regexp.host.some}{uri}
}

# ends:  just DOMAIN and requiring rewrite ... <<<<<<<<<<<

# starts: additional (long FQDN) >>>>>>>>>

# for ATP_APPVIEW_HOST=https://public.api.bsky.app in https://github.com/bluesky-social/social-app/blob/main/bskyweb/example.env
public.api.{$DOMAIN} {
	tls {$EMAIL4CERTS} {
          on_demand
        }
	reverse_proxy http://bsky:3000
}
# ends: additional (long FQDN)   <<<<<<<<<
